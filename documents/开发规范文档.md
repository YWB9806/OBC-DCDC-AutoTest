# Pythonè„šæœ¬æ‰¹é‡æ‰§è¡Œå·¥å…· - å¼€å‘è§„èŒƒæ–‡æ¡£

## æ–‡æ¡£ä¿¡æ¯
- **ç‰ˆæœ¬**: v1.0
- **åˆ›å»ºæ—¥æœŸ**: 2024-12-11
- **æ–‡æ¡£ç±»å‹**: å¼€å‘è§„èŒƒ
- **ç›®æ ‡è¯»è€…**: å¼€å‘å›¢é˜Ÿ

---

## ç›®å½•
1. [ä»£ç è§„èŒƒ](#1-ä»£ç è§„èŒƒ)
2. [å‘½åè§„èŒƒ](#2-å‘½åè§„èŒƒ)
3. [æ³¨é‡Šè§„èŒƒ](#3-æ³¨é‡Šè§„èŒƒ)
4. [Gitè§„èŒƒ](#4-gitè§„èŒƒ)
5. [æµ‹è¯•è§„èŒƒ](#5-æµ‹è¯•è§„èŒƒ)
6. [æ–‡æ¡£è§„èŒƒ](#6-æ–‡æ¡£è§„èŒƒ)

---

## 1. ä»£ç è§„èŒƒ

### 1.1 Pythonä»£ç è§„èŒƒ

**éµå¾ªPEP 8**:
- ä½¿ç”¨4ä¸ªç©ºæ ¼ç¼©è¿›
- æ¯è¡Œæœ€å¤š79ä¸ªå­—ç¬¦
- ç±»å’Œé¡¶çº§å‡½æ•°ä¹‹é—´ç©º2è¡Œ
- æ–¹æ³•ä¹‹é—´ç©º1è¡Œ

**ç¤ºä¾‹**:
```python
class ScriptManager:
    """è„šæœ¬ç®¡ç†å™¨
    
    è´Ÿè´£æ‰«æã€åŠ è½½å’Œç®¡ç†è„šæœ¬æ–‡ä»¶ã€‚
    """
    
    def __init__(self, root_path: str):
        """åˆå§‹åŒ–è„šæœ¬ç®¡ç†å™¨
        
        Args:
            root_path: è„šæœ¬æ ¹ç›®å½•è·¯å¾„
        """
        self.root_path = root_path
        self.scripts: Dict[str, ScriptInfo] = {}
    
    def scan_scripts(self, force_refresh: bool = False) -> List[ScriptInfo]:
        """æ‰«æè„šæœ¬ç›®å½•
        
        Args:
            force_refresh: æ˜¯å¦å¼ºåˆ¶åˆ·æ–°ç¼“å­˜
            
        Returns:
            è„šæœ¬ä¿¡æ¯åˆ—è¡¨
            
        Raises:
            FileNotFoundError: ç›®å½•ä¸å­˜åœ¨
        """
        if not os.path.exists(self.root_path):
            raise FileNotFoundError(f"Directory not found: {self.root_path}")
        
        # å®ç°ç»†èŠ‚...
        return []
```

### 1.2 ç±»å‹æ³¨è§£

**å¼ºåˆ¶ä½¿ç”¨ç±»å‹æ³¨è§£**:
```python
from typing import List, Dict, Optional, Union
from datetime import datetime

def execute_script(
    script: ScriptInfo,
    timeout: Optional[int] = None,
    env: Optional[Dict[str, str]] = None
) -> ExecutionRecord:
    """æ‰§è¡Œè„šæœ¬"""
    pass

def get_records(
    batch_id: Optional[str] = None,
    limit: int = 100
) -> List[ExecutionRecord]:
    """è·å–æ‰§è¡Œè®°å½•"""
    pass
```

### 1.3 å¯¼å…¥è§„èŒƒ

**å¯¼å…¥é¡ºåº**:
1. æ ‡å‡†åº“
2. ç¬¬ä¸‰æ–¹åº“
3. æœ¬åœ°æ¨¡å—

```python
# æ ‡å‡†åº“
import os
import sys
from datetime import datetime
from typing import List, Dict

# ç¬¬ä¸‰æ–¹åº“
from PyQt5.QtWidgets import QWidget
from PyQt5.QtCore import pyqtSignal

# æœ¬åœ°æ¨¡å—
from core.domain.script import ScriptInfo
from core.managers.script_manager import ScriptManager
from utils.exceptions import ValidationError
```

### 1.4 å¼‚å¸¸å¤„ç†

**æ˜ç¡®çš„å¼‚å¸¸å¤„ç†**:
```python
# å¥½çš„åšæ³•
try:
    result = execute_script(script)
except FileNotFoundError as e:
    logger.error(f"Script file not found: {e}")
    raise
except PermissionError as e:
    logger.error(f"Permission denied: {e}")
    raise
except Exception as e:
    logger.exception(f"Unexpected error: {e}")
    raise ExecutionError(f"Failed to execute script: {e}")

# é¿å…çš„åšæ³•
try:
    result = execute_script(script)
except:  # ä¸è¦ä½¿ç”¨è£¸except
    pass
```

### 1.5 èµ„æºç®¡ç†

**ä½¿ç”¨ä¸Šä¸‹æ–‡ç®¡ç†å™¨**:
```python
# å¥½çš„åšæ³•
with open(file_path, 'r', encoding='utf-8') as f:
    content = f.read()

with sqlite3.connect(db_path) as conn:
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM scripts")

# è‡ªå®šä¹‰ä¸Šä¸‹æ–‡ç®¡ç†å™¨
class DatabaseTransaction:
    def __init__(self, conn):
        self.conn = conn
    
    def __enter__(self):
        self.conn.execute("BEGIN TRANSACTION")
        return self.conn
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is None:
            self.conn.commit()
        else:
            self.conn.rollback()
```

---

## 2. å‘½åè§„èŒƒ

### 2.1 å‘½åé£æ ¼

| ç±»å‹ | è§„èŒƒ | ç¤ºä¾‹ |
|------|------|------|
| æ¨¡å— | å°å†™+ä¸‹åˆ’çº¿ | `script_manager.py` |
| ç±» | å¤§é©¼å³° | `ScriptManager` |
| å‡½æ•°/æ–¹æ³• | å°å†™+ä¸‹åˆ’çº¿ | `execute_script()` |
| å˜é‡ | å°å†™+ä¸‹åˆ’çº¿ | `script_path` |
| å¸¸é‡ | å¤§å†™+ä¸‹åˆ’çº¿ | `MAX_PARALLEL` |
| ç§æœ‰æˆå‘˜ | å‰ç¼€å•ä¸‹åˆ’çº¿ | `_internal_method()` |
| ç‰¹æ®Šæ–¹æ³• | åŒä¸‹åˆ’çº¿åŒ…å›´ | `__init__()` |

### 2.2 å‘½ååŸåˆ™

**æ¸…æ™°æ˜ç¡®**:
```python
# å¥½çš„å‘½å
def calculate_success_rate(success_count: int, total_count: int) -> float:
    return (success_count / total_count) * 100

# é¿å…çš„å‘½å
def calc(s: int, t: int) -> float:
    return (s / t) * 100
```

**åŠ¨è¯+åè¯**:
```python
# å‡½æ•°åä½¿ç”¨åŠ¨è¯å¼€å¤´
def get_script_info(path: str) -> ScriptInfo:
    pass

def save_execution_record(record: ExecutionRecord) -> bool:
    pass

def validate_script_path(path: str) -> bool:
    pass
```

**å¸ƒå°”å€¼å‘½å**:
```python
# ä½¿ç”¨is/has/canç­‰å‰ç¼€
is_running: bool = True
has_permission: bool = False
can_execute: bool = True
```

### 2.3 æ–‡ä»¶å‘½å

```
# æ¨¡å—æ–‡ä»¶
script_manager.py
execution_engine.py
result_analyzer.py

# æµ‹è¯•æ–‡ä»¶
test_script_manager.py
test_execution_engine.py

# é…ç½®æ–‡ä»¶
config.json
settings.ini
```

---

## 3. æ³¨é‡Šè§„èŒƒ

### 3.1 æ–‡æ¡£å­—ç¬¦ä¸²

**æ¨¡å—æ–‡æ¡£å­—ç¬¦ä¸²**:
```python
"""è„šæœ¬ç®¡ç†æ¨¡å—

æœ¬æ¨¡å—æä¾›è„šæœ¬çš„æ‰«æã€åŠ è½½ã€è¿‡æ»¤ç­‰åŠŸèƒ½ã€‚

ä¸»è¦ç±»:
    - ScriptManager: è„šæœ¬ç®¡ç†å™¨
    - ScriptScanner: è„šæœ¬æ‰«æå™¨

ç¤ºä¾‹:
    >>> manager = ScriptManager('/path/to/scripts')
    >>> scripts = manager.scan_scripts()
    >>> print(len(scripts))
    100
"""
```

**ç±»æ–‡æ¡£å­—ç¬¦ä¸²**:
```python
class ScriptManager:
    """è„šæœ¬ç®¡ç†å™¨
    
    è´Ÿè´£æ‰«æã€åŠ è½½å’Œç®¡ç†è„šæœ¬æ–‡ä»¶ã€‚æ”¯æŒç¼“å­˜å’Œå¢é‡æ›´æ–°ã€‚
    
    Attributes:
        root_path: è„šæœ¬æ ¹ç›®å½•è·¯å¾„
        scripts: è„šæœ¬ä¿¡æ¯å­—å…¸ï¼Œkeyä¸ºè„šæœ¬è·¯å¾„
        cache_manager: ç¼“å­˜ç®¡ç†å™¨å®ä¾‹
    
    Example:
        >>> manager = ScriptManager('/path/to/scripts')
        >>> scripts = manager.scan_scripts()
        >>> info = manager.get_script_info('test.py')
    """
```

**æ–¹æ³•æ–‡æ¡£å­—ç¬¦ä¸²**:
```python
def execute_script(
    self,
    script: ScriptInfo,
    timeout: Optional[int] = None
) -> ExecutionRecord:
    """æ‰§è¡Œå•ä¸ªè„šæœ¬
    
    åœ¨ç‹¬ç«‹è¿›ç¨‹ä¸­æ‰§è¡ŒæŒ‡å®šçš„Pythonè„šæœ¬ï¼Œå¹¶æ•è·è¾“å‡ºå’Œæ€§èƒ½æŒ‡æ ‡ã€‚
    
    Args:
        script: è„šæœ¬ä¿¡æ¯å¯¹è±¡
        timeout: è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ï¼ŒNoneè¡¨ç¤ºä½¿ç”¨é»˜è®¤å€¼
    
    Returns:
        ExecutionRecord: æ‰§è¡Œè®°å½•å¯¹è±¡ï¼ŒåŒ…å«çŠ¶æ€ã€è¾“å‡ºç­‰ä¿¡æ¯
    
    Raises:
        FileNotFoundError: è„šæœ¬æ–‡ä»¶ä¸å­˜åœ¨
        TimeoutError: æ‰§è¡Œè¶…æ—¶
        ExecutionError: æ‰§è¡Œè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯
    
    Example:
        >>> record = executor.execute_script(script, timeout=300)
        >>> print(record.status)
        'SUCCESS'
    
    Note:
        - æ‰§è¡Œè¿‡ç¨‹ä¸­ä¼šç›‘æ§CPUå’Œå†…å­˜ä½¿ç”¨
        - è¶…æ—¶åä¼šå¼ºåˆ¶ç»ˆæ­¢è¿›ç¨‹
        - è¾“å‡ºé™åˆ¶ä¸º10MB
    """
```

### 3.2 è¡Œå†…æ³¨é‡Š

```python
# å¥½çš„æ³¨é‡Šï¼šè§£é‡Šä¸ºä»€ä¹ˆè¿™æ ·åš
# ä½¿ç”¨è¿›ç¨‹æ± è€Œéçº¿ç¨‹æ± ï¼Œé¿å…GILé™åˆ¶
executor = ProcessPoolExecutor(max_workers=cpu_count())

# é¿å…çš„æ³¨é‡Šï¼šé‡å¤ä»£ç å†…å®¹
# åˆ›å»ºè¿›ç¨‹æ± æ‰§è¡Œå™¨
executor = ProcessPoolExecutor(max_workers=cpu_count())
```

### 3.3 TODOæ³¨é‡Š

```python
# TODO(username): æ·»åŠ é‡è¯•æœºåˆ¶
# FIXME(username): ä¿®å¤å¹¶å‘æ‰§è¡Œæ—¶çš„ç«æ€æ¡ä»¶
# HACK(username): ä¸´æ—¶è§£å†³æ–¹æ¡ˆï¼Œéœ€è¦é‡æ„
# NOTE(username): è¿™é‡Œçš„å®ç°ä¾èµ–äºPython 3.8+çš„ç‰¹æ€§
```

---

## 4. Gitè§„èŒƒ

### 4.1 åˆ†æ”¯ç­–ç•¥

```
main (ä¸»åˆ†æ”¯)
  â”œâ”€â”€ develop (å¼€å‘åˆ†æ”¯)
  â”‚   â”œâ”€â”€ feature/script-management (åŠŸèƒ½åˆ†æ”¯)
  â”‚   â”œâ”€â”€ feature/execution-engine (åŠŸèƒ½åˆ†æ”¯)
  â”‚   â””â”€â”€ feature/ui-components (åŠŸèƒ½åˆ†æ”¯)
  â”œâ”€â”€ hotfix/critical-bug (çƒ­ä¿®å¤åˆ†æ”¯)
  â””â”€â”€ release/v1.0.0 (å‘å¸ƒåˆ†æ”¯)
```

**åˆ†æ”¯å‘½å**:
- `feature/åŠŸèƒ½åç§°`: æ–°åŠŸèƒ½å¼€å‘
- `bugfix/é—®é¢˜æè¿°`: Bugä¿®å¤
- `hotfix/ç´§æ€¥é—®é¢˜`: ç´§æ€¥ä¿®å¤
- `release/ç‰ˆæœ¬å·`: å‘å¸ƒå‡†å¤‡
- `refactor/é‡æ„å†…å®¹`: ä»£ç é‡æ„

### 4.2 æäº¤ä¿¡æ¯è§„èŒƒ

**æ ¼å¼**:
```
<type>(<scope>): <subject>

<body>

<footer>
```

**ç±»å‹ (type)**:
- `feat`: æ–°åŠŸèƒ½
- `fix`: Bugä¿®å¤
- `docs`: æ–‡æ¡£æ›´æ–°
- `style`: ä»£ç æ ¼å¼ï¼ˆä¸å½±å“åŠŸèƒ½ï¼‰
- `refactor`: é‡æ„
- `test`: æµ‹è¯•ç›¸å…³
- `chore`: æ„å»º/å·¥å…·ç›¸å…³

**ç¤ºä¾‹**:
```
feat(script-manager): æ·»åŠ è„šæœ¬ç¼“å­˜åŠŸèƒ½

- å®ç°LRUç¼“å­˜ç®¡ç†å™¨
- æ·»åŠ ç¼“å­˜é…ç½®é€‰é¡¹
- ä¼˜åŒ–è„šæœ¬æ‰«ææ€§èƒ½

Closes #123
```

```
fix(execution-engine): ä¿®å¤å¹¶å‘æ‰§è¡Œæ—¶çš„å†…å­˜æ³„æ¼

åœ¨å¹¶è¡Œæ‰§è¡Œå¤§é‡è„šæœ¬æ—¶ï¼Œè¿›ç¨‹æ± æœªæ­£ç¡®é‡Šæ”¾èµ„æºã€‚
ç°åœ¨åœ¨æ‰§è¡Œå®Œæˆåæ˜¾å¼å…³é—­è¿›ç¨‹æ± ã€‚

Fixes #456
```

### 4.3 æäº¤æœ€ä½³å®è·µ

1. **å°è€Œé¢‘ç¹çš„æäº¤**: æ¯ä¸ªæäº¤åªåšä¸€ä»¶äº‹
2. **æœ‰æ„ä¹‰çš„æäº¤ä¿¡æ¯**: æ¸…æ¥šè¯´æ˜æ”¹åŠ¨å†…å®¹å’ŒåŸå› 
3. **æäº¤å‰æµ‹è¯•**: ç¡®ä¿ä»£ç å¯ä»¥è¿è¡Œ
4. **ä»£ç å®¡æŸ¥**: é‡è¦æ”¹åŠ¨éœ€è¦Code Review

---

## 5. æµ‹è¯•è§„èŒƒ

### 5.1 å•å…ƒæµ‹è¯•

**æµ‹è¯•æ–‡ä»¶ç»“æ„**:
```
tests/
â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ test_script_manager.py
â”‚   â”œâ”€â”€ test_execution_engine.py
â”‚   â””â”€â”€ test_result_analyzer.py
â”œâ”€â”€ integration/
â”‚   â”œâ”€â”€ test_execution_flow.py
â”‚   â””â”€â”€ test_database_operations.py
â””â”€â”€ fixtures/
    â”œâ”€â”€ sample_scripts/
    â””â”€â”€ test_data.json
```

**æµ‹è¯•ç¤ºä¾‹**:
```python
import pytest
from core.managers.script_manager import ScriptManager
from utils.exceptions import ValidationError

class TestScriptManager:
    """è„šæœ¬ç®¡ç†å™¨æµ‹è¯•"""
    
    @pytest.fixture
    def manager(self, tmp_path):
        """åˆ›å»ºæµ‹è¯•ç”¨çš„è„šæœ¬ç®¡ç†å™¨"""
        return ScriptManager(str(tmp_path))
    
    def test_scan_scripts_empty_directory(self, manager):
        """æµ‹è¯•æ‰«æç©ºç›®å½•"""
        scripts = manager.scan_scripts()
        assert len(scripts) == 0
    
    def test_scan_scripts_with_files(self, manager, tmp_path):
        """æµ‹è¯•æ‰«æåŒ…å«è„šæœ¬çš„ç›®å½•"""
        # åˆ›å»ºæµ‹è¯•è„šæœ¬
        script_file = tmp_path / "test.py"
        script_file.write_text("print('test')")
        
        scripts = manager.scan_scripts()
        assert len(scripts) == 1
        assert scripts[0].file_name == "test.py"
    
    def test_get_script_info_not_found(self, manager):
        """æµ‹è¯•è·å–ä¸å­˜åœ¨çš„è„šæœ¬"""
        info = manager.get_script_info("nonexistent.py")
        assert info is None
    
    @pytest.mark.parametrize("path,expected", [
        ("test.py", True),
        ("test.txt", False),
        ("__init__.py", False),
    ])
    def test_is_valid_script(self, manager, path, expected):
        """æµ‹è¯•è„šæœ¬è·¯å¾„éªŒè¯"""
        assert manager.is_valid_script(path) == expected
```

### 5.2 æµ‹è¯•è¦†ç›–ç‡

**ç›®æ ‡**: 80%ä»¥ä¸Šçš„ä»£ç è¦†ç›–ç‡

**è¿è¡Œæµ‹è¯•**:
```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
pytest

# è¿è¡Œç‰¹å®šæµ‹è¯•
pytest tests/unit/test_script_manager.py

# ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
pytest --cov=AppCode --cov-report=html

# æŸ¥çœ‹è¦†ç›–ç‡
open htmlcov/index.html
```

### 5.3 Mockå’ŒFixture

```python
from unittest.mock import Mock, patch
import pytest

@pytest.fixture
def mock_database():
    """æ¨¡æ‹Ÿæ•°æ®åº“è¿æ¥"""
    db = Mock()
    db.query.return_value = []
    return db

def test_with_mock_database(mock_database):
    """ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®åº“çš„æµ‹è¯•"""
    service = DataService(mock_database)
    result = service.get_records()
    assert result == []
    mock_database.query.assert_called_once()

@patch('core.engines.execution_engine.subprocess.run')
def test_execute_script(mock_run):
    """æ¨¡æ‹Ÿè„šæœ¬æ‰§è¡Œ"""
    mock_run.return_value = Mock(returncode=0, stdout="Success")
    
    engine = ExecutionEngine()
    result = engine.execute_script(script)
    
    assert result.status == "SUCCESS"
    mock_run.assert_called_once()
```

---

## 6. æ–‡æ¡£è§„èŒƒ

### 6.1 READMEæ–‡æ¡£

**å¿…é¡»åŒ…å«**:
- é¡¹ç›®ç®€ä»‹
- åŠŸèƒ½ç‰¹æ€§
- å®‰è£…è¯´æ˜
- å¿«é€Ÿå¼€å§‹
- é…ç½®è¯´æ˜
- å¸¸è§é—®é¢˜

**ç¤ºä¾‹**:
```markdown
# Pythonè„šæœ¬æ‰¹é‡æ‰§è¡Œå·¥å…·

## ç®€ä»‹
ä¸€æ¬¾åŸºäºPyQt5çš„æ¡Œé¢åº”ç”¨ï¼Œç”¨äºæ‰¹é‡ç®¡ç†å’Œæ‰§è¡ŒPythonæµ‹è¯•è„šæœ¬ã€‚

## åŠŸèƒ½ç‰¹æ€§
- ğŸš€ æ”¯æŒå¹¶è¡Œæ‰§è¡Œï¼Œå……åˆ†åˆ©ç”¨å¤šæ ¸CPU
- ğŸ“Š å®æ—¶æ€§èƒ½ç›‘æ§
- ğŸ“ è¯¦ç»†çš„æ‰§è¡Œæ—¥å¿—
- ğŸ‘¥ ç”¨æˆ·æƒé™ç®¡ç†

## å®‰è£…
\`\`\`bash
pip install -r requirements.txt
\`\`\`

## å¿«é€Ÿå¼€å§‹
\`\`\`python
python main.py
\`\`\`
```

### 6.2 APIæ–‡æ¡£

ä½¿ç”¨Sphinxç”ŸæˆAPIæ–‡æ¡£:
```bash
# å®‰è£…Sphinx
pip install sphinx

# åˆå§‹åŒ–æ–‡æ¡£
sphinx-quickstart docs

# ç”Ÿæˆæ–‡æ¡£
cd docs
make html
```

### 6.3 å˜æ›´æ—¥å¿—

**CHANGELOG.mdæ ¼å¼**:
```markdown
# å˜æ›´æ—¥å¿—

## [1.1.0] - 2024-12-15

### æ–°å¢
- æ·»åŠ æ€§èƒ½ç›‘æ§åŠŸèƒ½
- æ”¯æŒæ’ä»¶ç³»ç»Ÿ

### æ”¹è¿›
- ä¼˜åŒ–è„šæœ¬æ‰«ææ€§èƒ½
- æ”¹è¿›UIå“åº”é€Ÿåº¦

### ä¿®å¤
- ä¿®å¤å¹¶å‘æ‰§è¡Œæ—¶çš„å†…å­˜æ³„æ¼
- ä¿®å¤æ•°æ®åº“è¿æ¥æœªå…³é—­çš„é—®é¢˜

## [1.0.0] - 2024-12-11

### æ–°å¢
- åˆå§‹ç‰ˆæœ¬å‘å¸ƒ
- åŸºç¡€è„šæœ¬ç®¡ç†åŠŸèƒ½
- æ‰¹é‡æ‰§è¡ŒåŠŸèƒ½
```

---

## 7. ä»£ç å®¡æŸ¥æ¸…å•

### 7.1 åŠŸèƒ½æ€§
- [ ] ä»£ç å®ç°äº†éœ€æ±‚çš„åŠŸèƒ½
- [ ] è¾¹ç•Œæ¡ä»¶å¤„ç†æ­£ç¡®
- [ ] é”™è¯¯å¤„ç†å®Œå–„
- [ ] æ€§èƒ½æ»¡è¶³è¦æ±‚

### 7.2 ä»£ç è´¨é‡
- [ ] éµå¾ªPEP 8è§„èŒƒ
- [ ] å‘½åæ¸…æ™°æ˜ç¡®
- [ ] æ³¨é‡Šå……åˆ†
- [ ] æ— é‡å¤ä»£ç 

### 7.3 æµ‹è¯•
- [ ] æœ‰å•å…ƒæµ‹è¯•
- [ ] æµ‹è¯•è¦†ç›–ç‡è¾¾æ ‡
- [ ] æµ‹è¯•ç”¨ä¾‹å……åˆ†

### 7.4 å®‰å…¨æ€§
- [ ] æ— SQLæ³¨å…¥é£é™©
- [ ] æ— XSSé£é™©
- [ ] æ•æ„Ÿä¿¡æ¯å·²åŠ å¯†
- [ ] æƒé™æ£€æŸ¥å®Œå–„

---

## 8. æ€§èƒ½ä¼˜åŒ–æŒ‡å—

### 8.1 æ•°æ®åº“ä¼˜åŒ–
```python
# ä½¿ç”¨æ‰¹é‡æ“ä½œ
def batch_insert(records: List[ExecutionRecord]):
    conn.executemany(
        "INSERT INTO execution_history VALUES (?, ?, ?)",
        [(r.id, r.path, r.status) for r in records]
    )

# ä½¿ç”¨ç´¢å¼•
CREATE INDEX idx_script_path ON execution_history(script_path);

# ä½¿ç”¨è¿æ¥æ± 
from sqlalchemy import create_engine, pool
engine = create_engine(
    'sqlite:///app.db',
    poolclass=pool.QueuePool,
    pool_size=5
)
```

### 8.2 ç¼“å­˜ä¼˜åŒ–
```python
from functools import lru_cache

@lru_cache(maxsize=128)
def get_script_info(path: str) -> ScriptInfo:
    """ç¼“å­˜è„šæœ¬ä¿¡æ¯"""
    return load_script_info(path)

# æ¸…é™¤ç¼“å­˜
get_script_info.cache_clear()
```

### 8.3 å¹¶å‘ä¼˜åŒ–
```python
# ä½¿ç”¨è¿›ç¨‹æ± 
from concurrent.futures import ProcessPoolExecutor

with ProcessPoolExecutor(max_workers=4) as executor:
    futures = [executor.submit(execute_script, s) for s in scripts]
    results = [f.result() for f in futures]

# ä½¿ç”¨å¼‚æ­¥IO
import asyncio

async def execute_scripts_async(scripts):
    tasks = [execute_script_async(s) for s in scripts]
    return await asyncio.gather(*tasks)
```

---

## 9. å®‰å…¨ç¼–ç è§„èŒƒ

### 9.1 è¾“å…¥éªŒè¯
```python
def validate_script_path(path: str) -> bool:
    """éªŒè¯è„šæœ¬è·¯å¾„"""
    # æ£€æŸ¥è·¯å¾„éå†æ”»å‡»
    if '..' in path or path.startswith('/'):
        raise ValidationError("Invalid path")
    
    # æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
    if not path.endswith('.py'):
        raise ValidationError("Invalid file type")
    
    return True
```

### 9.2 å¯†ç å¤„ç†
```python
import hashlib
import secrets

def hash_password(password: str) -> str:
    """å“ˆå¸Œå¯†ç """
    salt = secrets.token_hex(16)
    pwd_hash = hashlib.pbkdf2_hmac(
        'sha256',
        password.encode('utf-8'),
        salt.encode('utf-8'),
        100000
    )
    return f"{salt}${pwd_hash.hex()}"

def verify_password(password: str, hashed: str) -> bool:
    """éªŒè¯å¯†ç """
    salt, pwd_hash = hashed.split('$')
    return hash_password(password).split('$')[1] == pwd_hash
```

### 9.3 SQLæ³¨å…¥é˜²æŠ¤
```python
# å¥½çš„åšæ³•ï¼šä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
cursor.execute(
    "SELECT * FROM scripts WHERE path = ?",
    (script_path,)
)

# é¿å…çš„åšæ³•ï¼šå­—ç¬¦ä¸²æ‹¼æ¥
cursor.execute(
    f"SELECT * FROM scripts WHERE path = '{script_path}'"
)
```

---

## é™„å½•

### A. å·¥å…·æ¨è

**ä»£ç è´¨é‡**:
- `pylint`: ä»£ç æ£€æŸ¥
- `black`: ä»£ç æ ¼å¼åŒ–
- `mypy`: ç±»å‹æ£€æŸ¥
- `isort`: å¯¼å…¥æ’åº

**æµ‹è¯•**:
- `pytest`: æµ‹è¯•æ¡†æ¶
- `pytest-cov`: è¦†ç›–ç‡
- `pytest-mock`: Mockå·¥å…·

**æ–‡æ¡£**:
- `sphinx`: æ–‡æ¡£ç”Ÿæˆ
- `mkdocs`: Markdownæ–‡æ¡£

### B. é…ç½®æ–‡ä»¶ç¤ºä¾‹

**pyproject.toml**:
```toml
[tool.black]
line-length = 88
target-version = ['py38']

[tool.isort]
profile = "black"
line_length = 88

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
```

---

**æ–‡æ¡£ç»´æŠ¤**: å¼€å‘å›¢é˜Ÿ  
**æœ€åæ›´æ–°**: 2024-12-11