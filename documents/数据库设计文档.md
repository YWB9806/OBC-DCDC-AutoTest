# Python脚本批量执行工具 - 数据库设计文档

## 文档信息
- **版本**: v1.0
- **创建日期**: 2024-12-11
- **文档类型**: 数据库设计
- **目标读者**: 开发团队、DBA

---

## 目录
1. [数据库概述](#1-数据库概述)
2. [表结构设计](#2-表结构设计)
3. [索引设计](#3-索引设计)
4. [数据库迁移](#4-数据库迁移)
5. [数据访问层](#5-数据访问层)
6. [性能优化](#6-性能优化)

---

## 1. 数据库概述

### 1.1 数据库选型
- **数据库**: SQLite 3.x
- **选型理由**:
  - 轻量级，无需独立服务器
  - 零配置，适合桌面应用
  - 支持事务，ACID特性
  - 跨平台，单文件存储

### 1.2 数据库文件
- **位置**: `data/app.db`
- **备份位置**: `backups/`
- **字符编码**: UTF-8

### 1.3 ER图

```
┌─────────────────┐         ┌─────────────────┐
│  batch_execution│1      N │execution_history│
│                 ├─────────┤                 │
│  - batch_id (PK)│         │  - record_id(PK)│
│  - batch_name   │         │  - batch_id (FK)│
│  - total_scripts│         │  - script_path  │
│  - start_time   │         │  - status       │
└─────────────────┘         └─────────────────┘
                                     │
                                     │1
                                     │
                                     │N
                            ┌─────────────────┐
                            │performance_     │
                            │metrics          │
                            │  - id (PK)      │
                            │  - record_id(FK)│
                            │  - cpu_percent  │
                            │  - memory_mb    │
                            └─────────────────┘

┌─────────────────┐         ┌─────────────────┐
│  users          │1      N │  user_sessions  │
│                 ├─────────┤                 │
│  - user_id (PK) │         │  - session_id(PK│
│  - username     │         │  - user_id (FK) │
│  - role         │         │  - login_time   │
└─────────────────┘         └─────────────────┘
```

---

## 2. 表结构设计

### 2.1 执行历史表 (execution_history)

**用途**: 记录每次脚本执行的详细信息

```sql
CREATE TABLE execution_history (
    -- 主键
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    record_id TEXT UNIQUE NOT NULL,
    
    -- 脚本信息
    script_path TEXT NOT NULL,
    script_name TEXT NOT NULL,
    module_name TEXT,
    
    -- 批次信息
    batch_id TEXT,
    
    -- 时间信息
    start_time DATETIME NOT NULL,
    end_time DATETIME,
    duration REAL,  -- 执行时长（秒）
    
    -- 状态信息
    status TEXT NOT NULL,  -- PENDING/RUNNING/SUCCESS/FAILED/ERROR/TIMEOUT
    result TEXT,           -- PASS/FAIL/UNKNOWN
    exit_code INTEGER,
    
    -- 输出信息
    output TEXT,
    error_message TEXT,
    stack_trace TEXT,
    
    -- 性能信息
    memory_usage REAL,     -- 内存使用（MB）
    cpu_usage REAL,        -- CPU使用率（%）
    peak_memory REAL,      -- 峰值内存（MB）
    
    -- 元数据
    executor_type TEXT DEFAULT 'process',  -- process/thread
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_execution_script_path ON execution_history(script_path);
CREATE INDEX idx_execution_batch_id ON execution_history(batch_id);
CREATE INDEX idx_execution_status ON execution_history(status);
CREATE INDEX idx_execution_start_time ON execution_history(start_time);
CREATE INDEX idx_execution_result ON execution_history(result);

-- 触发器：自动更新 updated_at
CREATE TRIGGER update_execution_timestamp 
AFTER UPDATE ON execution_history
BEGIN
    UPDATE execution_history 
    SET updated_at = CURRENT_TIMESTAMP 
    WHERE id = NEW.id;
END;
```

**字段说明**:
- `record_id`: UUID格式的唯一标识
- `status`: 执行状态，用于跟踪执行进度
- `result`: 测试结果，从输出中解析
- `duration`: 计算值 = end_time - start_time

### 2.2 批次执行表 (batch_execution)

**用途**: 记录批量执行的汇总信息

```sql
CREATE TABLE batch_execution (
    -- 主键
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    batch_id TEXT UNIQUE NOT NULL,
    
    -- 批次信息
    batch_name TEXT,
    description TEXT,
    
    -- 统计信息
    total_scripts INTEGER DEFAULT 0,
    completed_count INTEGER DEFAULT 0,
    success_count INTEGER DEFAULT 0,
    failed_count INTEGER DEFAULT 0,
    error_count INTEGER DEFAULT 0,
    timeout_count INTEGER DEFAULT 0,
    cancelled_count INTEGER DEFAULT 0,
    
    -- 时间信息
    start_time DATETIME NOT NULL,
    end_time DATETIME,
    duration REAL,
    estimated_remaining REAL,
    
    -- 性能信息
    avg_memory_usage REAL,
    avg_cpu_usage REAL,
    peak_memory_usage REAL,
    
    -- 执行配置
    execution_mode TEXT,  -- sequential/parallel
    max_parallel INTEGER,
    
    -- 用户信息
    user_id TEXT,
    
    -- 元数据
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_batch_batch_id ON batch_execution(batch_id);
CREATE INDEX idx_batch_start_time ON batch_execution(start_time);
CREATE INDEX idx_batch_user_id ON batch_execution(user_id);

-- 触发器
CREATE TRIGGER update_batch_timestamp 
AFTER UPDATE ON batch_execution
BEGIN
    UPDATE batch_execution 
    SET updated_at = CURRENT_TIMESTAMP 
    WHERE id = NEW.id;
END;
```

### 2.3 批次详情表 (batch_details)

**用途**: 关联批次和执行记录

```sql
CREATE TABLE batch_details (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    batch_id TEXT NOT NULL,
    record_id TEXT NOT NULL,
    execution_order INTEGER,  -- 执行顺序
    
    FOREIGN KEY (batch_id) REFERENCES batch_execution(batch_id) ON DELETE CASCADE,
    FOREIGN KEY (record_id) REFERENCES execution_history(record_id) ON DELETE CASCADE
);

-- 索引
CREATE INDEX idx_batch_details_batch_id ON batch_details(batch_id);
CREATE INDEX idx_batch_details_record_id ON batch_details(record_id);
CREATE UNIQUE INDEX idx_batch_details_unique ON batch_details(batch_id, record_id);
```

### 2.4 性能监控表 (performance_metrics)

**用途**: 记录执行过程中的性能指标

```sql
CREATE TABLE performance_metrics (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    record_id TEXT NOT NULL,
    timestamp DATETIME NOT NULL,
    
    -- CPU指标
    cpu_percent REAL,
    cpu_count INTEGER,
    
    -- 内存指标
    memory_mb REAL,
    memory_percent REAL,
    memory_available_mb REAL,
    
    -- 磁盘IO
    disk_read_mb REAL,
    disk_write_mb REAL,
    
    -- 进程信息
    active_threads INTEGER,
    active_processes INTEGER,
    
    FOREIGN KEY (record_id) REFERENCES execution_history(record_id) ON DELETE CASCADE
);

-- 索引
CREATE INDEX idx_metrics_record_id ON performance_metrics(record_id);
CREATE INDEX idx_metrics_timestamp ON performance_metrics(timestamp);
```

### 2.5 用户表 (users)

**用途**: 管理用户信息和权限

```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id TEXT UNIQUE NOT NULL,
    username TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    
    -- 角色和权限
    role TEXT NOT NULL DEFAULT 'user',  -- admin/user
    permissions TEXT,  -- JSON格式的权限列表
    
    -- 用户信息
    email TEXT,
    full_name TEXT,
    
    -- 状态
    is_active BOOLEAN DEFAULT 1,
    last_login DATETIME,
    
    -- 元数据
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_role ON users(role);
```

### 2.6 用户会话表 (user_sessions)

**用途**: 记录用户登录会话

```sql
CREATE TABLE user_sessions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    session_id TEXT UNIQUE NOT NULL,
    user_id TEXT NOT NULL,
    
    -- 会话信息
    login_time DATETIME NOT NULL,
    logout_time DATETIME,
    last_activity DATETIME,
    
    -- 客户端信息
    ip_address TEXT,
    user_agent TEXT,
    
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
);

-- 索引
CREATE INDEX idx_sessions_user_id ON user_sessions(user_id);
CREATE INDEX idx_sessions_session_id ON user_sessions(session_id);
```

### 2.7 备份记录表 (backup_records)

**用途**: 记录数据库备份历史

```sql
CREATE TABLE backup_records (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    backup_id TEXT UNIQUE NOT NULL,
    
    -- 备份信息
    backup_path TEXT NOT NULL,
    backup_size INTEGER,  -- 字节
    backup_time DATETIME NOT NULL,
    
    -- 备份类型
    backup_type TEXT,  -- MANUAL/AUTO/SCHEDULED
    
    -- 状态
    status TEXT,  -- SUCCESS/FAILED
    error_message TEXT,
    
    -- 描述
    description TEXT,
    
    -- 元数据
    created_by TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_backup_time ON backup_records(backup_time);
CREATE INDEX idx_backup_status ON backup_records(status);
```

### 2.8 数据库版本表 (schema_version)

**用途**: 管理数据库版本和迁移历史

```sql
CREATE TABLE schema_version (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    version TEXT NOT NULL,
    description TEXT,
    applied_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    -- 迁移脚本信息
    script_name TEXT,
    checksum TEXT
);

-- 索引
CREATE INDEX idx_schema_version ON schema_version(version);
```

### 2.9 审计日志表 (audit_logs)

**用途**: 记录重要操作的审计日志

```sql
CREATE TABLE audit_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    
    -- 操作信息
    action TEXT NOT NULL,  -- CREATE/UPDATE/DELETE/EXECUTE
    entity_type TEXT NOT NULL,  -- SCRIPT/BATCH/USER/CONFIG
    entity_id TEXT,
    
    -- 用户信息
    user_id TEXT,
    username TEXT,
    
    -- 详细信息
    details TEXT,  -- JSON格式
    
    -- 结果
    status TEXT,  -- SUCCESS/FAILED
    error_message TEXT,
    
    -- 时间戳
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_audit_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_action ON audit_logs(action);
CREATE INDEX idx_audit_created_at ON audit_logs(created_at);
```

---

## 3. 索引设计

### 3.1 索引策略

**原则**:
1. 为频繁查询的字段创建索引
2. 为外键创建索引
3. 为排序字段创建索引
4. 避免过多索引影响写入性能

### 3.2 复合索引

```sql
-- 批次执行的时间范围查询
CREATE INDEX idx_batch_time_range 
ON batch_execution(start_time, end_time);

-- 执行历史的脚本和状态组合查询
CREATE INDEX idx_execution_script_status 
ON execution_history(script_path, status);

-- 用户会话的用户和时间查询
CREATE INDEX idx_session_user_time 
ON user_sessions(user_id, login_time);
```

---

## 4. 数据库迁移

### 4.1 迁移管理器

```python
class MigrationManager:
    """数据库迁移管理器"""
    
    def __init__(self, db_path: str, migrations_dir: str):
        self.db_path = db_path
        self.migrations_dir = migrations_dir
    
    def get_current_version(self) -> str:
        """获取当前数据库版本"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            cursor.execute(
                "SELECT version FROM schema_version "
                "ORDER BY applied_at DESC LIMIT 1"
            )
            result = cursor.fetchone()
            return result[0] if result else "0.0.0"
        finally:
            conn.close()
    
    def get_pending_migrations(self) -> List[str]:
        """获取待执行的迁移"""
        current_version = self.get_current_version()
        all_migrations = self._scan_migrations()
        
        return [m for m in all_migrations if m > current_version]
    
    def apply_migration(self, version: str):
        """应用迁移"""
        migration_file = f"{self.migrations_dir}/v{version}.py"
        migration = self._load_migration(migration_file)
        
        conn = sqlite3.connect(self.db_path)
        try:
            conn.execute("BEGIN TRANSACTION")
            
            # 执行迁移
            migration.upgrade(conn)
            
            # 记录版本
            conn.execute(
                "INSERT INTO schema_version (version, description, script_name) "
                "VALUES (?, ?, ?)",
                (version, migration.description, migration_file)
            )
            
            conn.commit()
        except Exception as e:
            conn.rollback()
            raise
        finally:
            conn.close()
```

### 4.2 迁移脚本示例

```python
# migrations/versions/v1_0_0_initial.py
"""初始化数据库"""

def upgrade(conn):
    """升级到v1.0.0"""
    # 创建执行历史表
    conn.execute("""
        CREATE TABLE execution_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            record_id TEXT UNIQUE NOT NULL,
            script_path TEXT NOT NULL,
            -- ... 其他字段
        )
    """)
    
    # 创建索引
    conn.execute("""
        CREATE INDEX idx_execution_script_path 
        ON execution_history(script_path)
    """)

def downgrade(conn):
    """降级"""
    conn.execute("DROP TABLE IF EXISTS execution_history")

description = "初始化数据库结构"
```

---

## 5. 数据访问层

### 5.1 仓储模式实现

```python
class ExecutionRecordRepository:
    """执行记录仓储"""
    
    def __init__(self, db_path: str):
        self.db_path = db_path
    
    def save(self, record: ExecutionRecord) -> bool:
        """保存记录"""
        conn = sqlite3.connect(self.db_path)
        try:
            conn.execute("""
                INSERT INTO execution_history 
                (record_id, script_path, script_name, status, start_time)
                VALUES (?, ?, ?, ?, ?)
            """, (record.record_id, record.script_path, 
                  record.script_name, record.status, record.start_time))
            conn.commit()
            return True
        except Exception as e:
            conn.rollback()
            raise
        finally:
            conn.close()
    
    def find_by_id(self, record_id: str) -> Optional[ExecutionRecord]:
        """根据ID查找"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        try:
            cursor = conn.execute(
                "SELECT * FROM execution_history WHERE record_id = ?",
                (record_id,)
            )
            row = cursor.fetchone()
            return self._row_to_record(row) if row else None
        finally:
            conn.close()
    
    def find_by_batch(self, batch_id: str) -> List[ExecutionRecord]:
        """根据批次ID查找"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        try:
            cursor = conn.execute(
                "SELECT * FROM execution_history WHERE batch_id = ? "
                "ORDER BY start_time",
                (batch_id,)
            )
            return [self._row_to_record(row) for row in cursor.fetchall()]
        finally:
            conn.close()
```

---

## 6. 性能优化

### 6.1 查询优化

```sql
-- 使用EXPLAIN QUERY PLAN分析查询
EXPLAIN QUERY PLAN
SELECT * FROM execution_history 
WHERE script_path = 'test.py' AND status = 'SUCCESS';

-- 使用覆盖索引
CREATE INDEX idx_execution_covering 
ON execution_history(script_path, status, start_time, duration);
```

### 6.2 批量操作

```python
def batch_insert_records(records: List[ExecutionRecord]):
    """批量插入记录"""
    conn = sqlite3.connect(db_path)
    try:
        conn.execute("BEGIN TRANSACTION")
        
        conn.executemany("""
            INSERT INTO execution_history 
            (record_id, script_path, status, start_time)
            VALUES (?, ?, ?, ?)
        """, [(r.record_id, r.script_path, r.status, r.start_time) 
              for r in records])
        
        conn.commit()
    except:
        conn.rollback()
        raise
    finally:
        conn.close()
```

### 6.3 数据清理

```sql
-- 定期清理旧数据
DELETE FROM execution_history 
WHERE start_time < datetime('now', '-90 days');

-- 清理后优化数据库
VACUUM;
ANALYZE;
```

---

## 附录

### A. 数据字典

详见各表结构说明。

### B. 备份策略

