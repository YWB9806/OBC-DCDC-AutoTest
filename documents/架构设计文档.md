# Python脚本批量执行工具 - 架构设计文档

## 文档信息
- **版本**: v1.0
- **创建日期**: 2024-12-11
- **文档类型**: 架构设计
- **目标读者**: 开发团队、架构师

---

## 目录
1. [架构概述](#1-架构概述)
2. [架构模式](#2-架构模式)
3. [模块设计](#3-模块设计)
4. [核心接口定义](#4-核心接口定义)
5. [依赖关系](#5-依赖关系)
6. [扩展机制](#6-扩展机制)

---

## 1. 架构概述

### 1.1 架构目标
- **高性能**: 支持大规模脚本并行执行
- **高可靠**: 完善的异常处理和数据保护
- **可扩展**: 插件化架构，易于功能扩展
- **可维护**: 清晰的分层结构，职责明确
- **可测试**: 接口隔离，便于单元测试

### 1.2 架构原则
1. **关注点分离**: 各层职责明确，互不干扰
2. **依赖倒置**: 依赖抽象而非具体实现
3. **开闭原则**: 对扩展开放，对修改关闭
4. **单一职责**: 每个模块只负责一个功能
5. **接口隔离**: 使用最小化接口

### 1.3 技术选型

| 技术 | 选型 | 理由 |
|------|------|------|
| UI框架 | PyQt5 | 成熟稳定、跨平台、丰富的控件 |
| 数据库 | SQLite | 轻量级、无需配置、适合桌面应用 |
| 并发 | multiprocessing | 避免GIL限制，充分利用多核 |
| 缓存 | LRU Cache | 简单高效，适合频繁访问的数据 |
| 日志 | logging | Python标准库，功能完善 |

---

## 2. 架构模式

### 2.1 分层架构

```
┌─────────────────────────────────────────────────────────────┐
│                 表示层 (Presentation Layer)                  │
│  职责: UI展示、用户交互、数据绑定                             │
│  技术: PyQt5 Widgets + ViewModels                            │
└─────────────────────────────────────────────────────────────┘
                           ↓↑ (PyQt信号/槽)
┌─────────────────────────────────────────────────────────────┐
│                应用服务层 (Application Layer)                │
│  职责: 用例协调、业务流程、DTO转换                            │
│  技术: Service Classes                                       │
└─────────────────────────────────────────────────────────────┘
                           ↓↑ (接口调用)
┌─────────────────────────────────────────────────────────────┐
│                   领域层 (Domain Layer)                      │
│  职责: 核心业务逻辑、领域模型、业务规则                       │
│  技术: Domain Models + Domain Services                       │
└─────────────────────────────────────────────────────────────┘
                           ↓↑ (依赖注入)
┌─────────────────────────────────────────────────────────────┐
│               基础设施层 (Infrastructure Layer)              │
│  职责: 技术实现、数据持久化、外部服务                         │
│  技术: SQLite + File System + Process Pool                   │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 MVVM模式

```
View (UI) ←→ ViewModel ←→ Model (Domain)
```

**优势**:
- View和业务逻辑完全解耦
- ViewModel可独立测试
- 支持数据双向绑定

---

## 3. 模块设计

### 3.1 目录结构

```
AppCode/
├── ui/                    # 表示层
│   ├── viewmodels/       # 视图模型
│   ├── widgets/          # UI组件
│   ├── dialogs/          # 对话框
│   └── resources/        # 资源文件
├── services/             # 应用服务层
├── core/                 # 领域层
│   ├── domain/          # 领域模型
│   ├── managers/        # 管理器
│   ├── engines/         # 引擎
│   └── analyzers/       # 分析器
├── infrastructure/       # 基础设施层
│   ├── data/            # 数据访问
│   ├── logging/         # 日志系统
│   ├── threading/       # 线程/进程
│   └── storage/         # 存储管理
├── utils/                # 工具模块
├── plugins/              # 插件系统
└── tests/                # 测试代码
```

### 3.2 模块职责矩阵

| 层次 | 模块 | 职责 | 依赖 |
|------|------|------|------|
| 表示层 | ui/ | UI展示、用户交互 | services/ |
| 应用服务层 | services/ | 用例协调、流程编排 | core/, infrastructure/ |
| 领域层 | core/ | 核心业务逻辑 | infrastructure/接口 |
| 基础设施层 | infrastructure/ | 技术实现 | 无 |

---

## 4. 核心接口定义

### 4.1 脚本管理接口

```python
from abc import ABC, abstractmethod
from typing import List, Optional
from core.domain.script import ScriptInfo

class IScriptManager(ABC):
    """脚本管理器接口"""
    
    @abstractmethod
    def scan_scripts(self, force_refresh: bool = False) -> List[ScriptInfo]:
        """扫描脚本目录"""
        pass
    
    @abstractmethod
    def get_script_info(self, path: str) -> Optional[ScriptInfo]:
        """获取脚本信息"""
        pass
    
    @abstractmethod
    def filter_scripts(self, **criteria) -> List[ScriptInfo]:
        """过滤脚本"""
        pass
```

### 4.2 执行引擎接口

```python
from abc import ABC, abstractmethod
from typing import List
from concurrent.futures import Future

class IExecutionEngine(ABC):
    """执行引擎接口"""
    
    @abstractmethod
    def execute_script(self, script: ScriptInfo) -> Future:
        """执行单个脚本"""
        pass
    
    @abstractmethod
    def execute_batch(self, scripts: List[ScriptInfo], mode: str) -> str:
        """批量执行脚本，返回批次ID"""
        pass
    
    @abstractmethod
    def stop_execution(self, batch_id: str = None):
        """停止执行"""
        pass
```

### 4.3 数据访问接口

```python
from abc import ABC, abstractmethod
from typing import List, Optional
from core.domain.execution import ExecutionRecord

class IDataAccess(ABC):
    """数据访问接口（仓储模式）"""
    
    @abstractmethod
    def save_record(self, record: ExecutionRecord) -> bool:
        """保存执行记录"""
        pass
    
    @abstractmethod
    def query_records(self, **filters) -> List[ExecutionRecord]:
        """查询执行记录"""
        pass
    
    @abstractmethod
    def begin_transaction(self):
        """开始事务"""
        pass
    
    @abstractmethod
    def commit_transaction(self):
        """提交事务"""
        pass
```

### 4.4 缓存管理接口

```python
from abc import ABC, abstractmethod
from typing import Optional, Any

class ICacheManager(ABC):
    """缓存管理器接口"""
    
    @abstractmethod
    def get(self, key: str) -> Optional[Any]:
        """获取缓存"""
        pass
    
    @abstractmethod
    def set(self, key: str, value: Any, ttl: int = None):
        """设置缓存"""
        pass
    
    @abstractmethod
    def clear(self, pattern: str = None):
        """清除缓存"""
        pass
```

### 4.5 监控服务接口

```python
from abc import ABC, abstractmethod
from typing import List
from datetime import datetime
from core.domain.performance import PerformanceMetrics

class IMonitoringService(ABC):
    """监控服务接口"""
    
    @abstractmethod
    def start_monitoring(self, target_id: str):
        """开始监控"""
        pass
    
    @abstractmethod
    def stop_monitoring(self, target_id: str):
        """停止监控"""
        pass
    
    @abstractmethod
    def get_metrics(self, target_id: str) -> PerformanceMetrics:
        """获取性能指标"""
        pass
```

### 4.6 权限管理接口

```python
from abc import ABC, abstractmethod
from core.domain.user import UserRole

class IPermissionManager(ABC):
    """权限管理器接口"""
    
    @abstractmethod
    def check_permission(self, user_id: str, permission: str) -> bool:
        """检查用户权限"""
        pass
    
    @abstractmethod
    def get_user_role(self, user_id: str) -> UserRole:
        """获取用户角色"""
        pass
    
    @abstractmethod
    def assign_role(self, user_id: str, role: UserRole):
        """分配角色"""
        pass
```

### 4.7 插件接口

```python
from abc import ABC, abstractmethod
from typing import Dict, Any

class IPlugin(ABC):
    """插件接口"""
    
    @abstractmethod
    def get_name(self) -> str:
        """获取插件名称"""
        pass
    
    @abstractmethod
    def initialize(self, context: Dict[str, Any]):
        """初始化插件"""
        pass
    
    @abstractmethod
    def execute(self, **kwargs) -> Any:
        """执行插件功能"""
        pass
    
    @abstractmethod
    def cleanup(self):
        """清理资源"""
        pass
```

---

## 5. 依赖关系

### 5.1 依赖规则

1. **单向依赖**: 上层依赖下层，下层不依赖上层
2. **接口隔离**: 通过接口定义依赖
3. **依赖注入**: 构造函数注入
4. **最小知识**: 只与直接依赖交互

### 5.2 依赖注入示例

```python
class ExecutionService:
    """执行服务 - 应用服务层"""
    
    def __init__(self,
                 execution_engine: IExecutionEngine,
                 data_access: IDataAccess,
                 monitoring_service: IMonitoringService,
                 cache_manager: ICacheManager,
                 permission_manager: IPermissionManager):
        """通过构造函数注入所有依赖"""
        self._engine = execution_engine
        self._data_access = data_access
        self._monitoring = monitoring_service
        self._cache = cache_manager
        self._permission = permission_manager
    
    def execute_scripts(self, user_id: str, script_ids: List[str]) -> str:
        """执行脚本用例"""
        # 1. 权限检查
        if not self._permission.check_permission(user_id, "execute_scripts"):
            raise PermissionError("用户无执行权限")
        
        # 2. 从缓存获取脚本信息
        scripts = [self._cache.get(f"script:{id}") for id in script_ids]
        
        # 3. 开始执行
        batch_id = self._engine.execute_batch(scripts, mode="parallel")
        
        # 4. 开始监控
        self._monitoring.start_monitoring(batch_id)
        
        return batch_id
```

### 5.3 依赖注入容器

```python
class DIContainer:
    """依赖注入容器"""
    
    def __init__(self):
        self._services = {}
    
    def register(self, interface, implementation):
        """注册服务"""
        self._services[interface] = implementation
    
    def resolve(self, interface):
        """解析服务"""
        return self._services.get(interface)

# 应用启动时设置依赖
def setup_dependencies():
    container = DIContainer()
    
    # 注册基础设施层
    container.register(IDataAccess, SQLiteDataAccess())
    container.register(ICacheManager, LRUCacheManager())
    
    # 注册领域层
    container.register(IScriptManager, ScriptManager(
        cache_manager=container.resolve(ICacheManager)
    ))
    
    # 注册应用服务层
    container.register(ExecutionService, ExecutionService(
        execution_engine=container.resolve(IExecutionEngine),
        data_access=container.resolve(IDataAccess),
        # ... 其他依赖
    ))
    
    return container
```

---

## 6. 扩展机制

### 6.1 插件系统架构

```
┌─────────────────────────────────────────┐
│         Plugin Manager                   │
│  - 加载插件                              │
│  - 管理生命周期                          │
│  - 提供上下文                            │
└─────────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────┐
│         Plugin Loader                    │
│  - 扫描插件目录                          │
│  - 动态加载模块                          │
│  - 验证插件接口                          │
└─────────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────┐
│         Plugin Interface                 │
│  - IPlugin (基础接口)                    │
│  - IReportPlugin (报告插件)              │
│  - INotificationPlugin (通知插件)        │
└─────────────────────────────────────────┘
```

### 6.2 插件开发示例

```python
from plugins.plugin_interface import IPlugin

class HTMLReportPlugin(IPlugin):
    """HTML报告生成插件"""
    
    def get_name(self) -> str:
        return "HTML Report Generator"
    
    def get_version(self) -> str:
        return "1.0.0"
    
    def initialize(self, context: Dict[str, Any]):
        """初始化插件"""
        self.data_access = context.get('data_access')
        self.template_path = context.get('template_path')
    
    def execute(self, **kwargs) -> Any:
        """生成HTML报告"""
        batch_id = kwargs.get('batch_id')
        
        # 获取数据
        records = self.data_access.query_records(batch_id=batch_id)
        
        # 生成报告
        report_html = self._generate_html(records)
        
        # 保存文件
        output_path = kwargs.get('output_path', 'report.html')
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(report_html)
        
        return output_path
    
    def cleanup(self):
        """清理资源"""
        pass
    
    def _generate_html(self, records):
        """生成HTML内容"""
        # 实现细节...
        pass
```

### 6.3 扩展点

系统提供以下扩展点：

1. **报告生成**: 自定义报告格式（HTML、PDF、Excel等）
2. **通知服务**: 自定义通知方式（邮件、钉钉、企业微信等）
3. **数据导出**: 自定义导出格式
4. **结果分析**: 自定义分析算法
5. **UI主题**: 自定义界面主题

### 6.4 API接口（预留）

```python
from flask import Flask, jsonify, request

app = Flask(__name__)

@app.route('/api/v1/scripts', methods=['GET'])
def get_scripts():
    """获取脚本列表"""
    script_service = container.resolve(ScriptService)
    scripts = script_service.get_all_scripts()
    return jsonify([s.to_dict() for s in scripts])

@app.route('/api/v1/execute', methods=['POST'])
def execute_scripts():
    """执行脚本"""
    data = request.json
    user_id = data.get('user_id')
    script_ids = data.get('script_ids')
    
    execution_service = container.resolve(ExecutionService)
    batch_id = execution_service.execute_scripts(user_id, script_ids)
    
    return jsonify({'batch_id': batch_id})

@app.route('/api/v1/status/<batch_id>', methods=['GET'])
def get_status(batch_id):
    """获取执行状态"""
    execution_service = container.resolve(ExecutionService)
    status = execution_service.get_execution_status(batch_id)
    return jsonify(status)
```

---

## 7. 架构决策记录 (ADR)

### ADR-001: 采用分层架构
**日期**: 2024-12-11  
**状态**: 已接受  
**决策**: 采用四层架构（表示层、应用服务层、领域层、基础设施层）  
**理由**: 
- 职责清晰，易于维护
- 便于单元测试
- 支持技术栈替换

### ADR-002: 使用进程池执行脚本
**日期**: 2024-12-11  
**状态**: 已接受  
**决策**: 使用multiprocessing.Pool执行脚本  
**理由**:
- 避免GIL限制
- 充分利用多核CPU
- 进程隔离，提高稳定性

### ADR-003: 采用依赖注入
**日期**: 2024-12-11  
**状态**: 已接受  
**决策**: 使用构造函数注入依赖  
**理由**:
- 降低模块耦合
- 便于单元测试（可mock依赖）
- 提高代码可维护性

### ADR-004: 插件系统基于接口
**日期**: 2024-12-11  
**状态**: 已接受  
**决策**: 插件必须实现IPlugin接口  
**理由**:
- 统一插件规范
- 便于插件管理
- 支持动态加载

---

## 8. 架构演进路线

### 阶段1: MVP (最小可行产品)
- 基础UI框架
- 脚本扫描和执行
- 简单的结果展示
- SQLite数据存储

### 阶段2: 功能完善
- 性能监控
- 数据备份
- 用户权限管理
- 插件系统基础

### 阶段3: 高级特性
- 完整的插件生态
- RESTful API
- 沙箱执行
- 分布式执行（可选）

### 阶段4: 企业级
- 多租户支持
- 审计日志
- 高可用部署
- 性能优化

---

## 附录

### A. 参考资料
- Clean Architecture (Robert C. Martin)
- Domain-Driven Design (Eric Evans)
- PyQt5 Documentation
- Python Multiprocessing Guide

### B. 术语表
- **DTO**: Data Transfer Object，数据传输对象
- **DI**: Dependency Injection，依赖注入
- **MVVM**: Model-View-ViewModel
- **ADR**: Architecture Decision Record，架构决策记录
- **GIL**: Global Interpreter Lock，全局解释器锁

---

**文档维护**: 开发团队  
**最后更新**: 2024-12-11